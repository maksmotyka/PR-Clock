<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polskie Radio - Zegar</title>
    <style>
        @font-face {
            font-family: 'DigiClock';
            src: url('fonts/DigiClock.woff') format('woff'),
                 url('fonts/DigiClock.woff2') format('woff2'),
                 url('fonts/DigiClock.svg#DigiClock') format('svg'),
                 url('fonts/DigiClock.eot'),
                 url('fonts/DigiClock.eot?#iefix') format('embedded-opentype'),
                 url('fonts/DigiClock.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-image: url(clock/background.jpg);
            background-size: cover;
            background-attachment: fixed;
            overflow: hidden;
        }

        #clocks-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            padding-top: 3vh;
            padding-bottom: 5vh;
            transform: scale(0.95);
        }

        #analog-clock-container {
            position: relative;
            width: 80vmin;
            height: 80vmin;
            max-width: 90vw;
            max-height: 90vh;
            transition: all 0.3s ease;
        }

        .clock {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-image: url(clock/face.png);
            background-size: contain;
            background-position: 50% 50%;
            background-repeat: no-repeat;
        }

        .clock > * {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }
        .clock > * > * {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-size: contain;
            background-position: 50% 50%;
            background-repeat: no-repeat;
            transform-origin: 50% 50%;
        }

        .clock .second-hand { z-index: 100; }
        .clock .second-hand-inner { background-image: url(clock/hand-second.png); }
        .clock .minute-hand { z-index: 99; }
        .clock .minute-hand-inner { background-image: url(clock/hand-minute.png); }
        .clock .hour-hand { z-index: 98; }
        .clock .hour-hand-inner { background-image: url(clock/hand-hour.png); }

        #digital-clock {
            font-family: 'DigiClock';
            color: #f00;
            text-shadow: 0 0 10px #f00;
            margin-top: 20px;
            padding: 20px;
            border: 10px solid #444;
            border-radius: 15px;
            background-color: #000;
            text-align: center;
            transition: all 0.3s ease;
            letter-spacing: -0.40em;
            position: relative;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }

        #controls label {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 14px;
        }

        #sync-status {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.5s ease, background-color 0.3s ease;
        }

        #sync-status.syncing {
            background-color: rgba(255, 165, 0, 0.8);
        }

        #sync-status.hidden {
            opacity: 0;
            pointer-events: none;
        }

    </style>
</head>
<body>
    <div id="clocks-container">
        <div id="analog-clock-container">
            <div class='clock' id="analog-clock">
                <div class='hour-hand'><div class='hour-hand-inner'></div></div>
                <div class='minute-hand'><div class='minute-hand-inner'></div></div>
                <div class='second-hand'><div class='second-hand-inner'></div></div>
            </div>
        </div>
        <div id="digital-clock"></div>
    </div>

    <div id="controls">
        <label><input type="checkbox" id="show-analog" checked> Analogowy</label><br>
        <label><input type="checkbox" id="show-digital" checked> Cyfrowy</label><br>
        <label><input type="checkbox" id="enable-pips"> GUM</label><br>
        <label><input type="checkbox" id="show-status"> Status</label>
    </div>

    <script>
        // =============================================================================
        // MODU≈Å SYNCHRONIZACJI CZASU Z NTP GUM + INTELIGENTNA RESYNCHRONIZACJA
        // =============================================================================

        const BACKEND_URL = 'https://timeserv.maksplus.xyz/api/time';
        
        const FALLBACK_SERVERS = [
            {
                name: 'WorldTimeAPI',
                url: 'https://worldtimeapi.org/api/timezone/Europe/Warsaw',
                parse: (data) => new Date(data.datetime)
            }
        ];

        let timeOffset = 0;
        let timeSourceUsed = 'system';
        let ntpServerUsed = 'Nieznany';
        let lastSyncTime = 0;
        let syncCount = 0;
        let resyncTimer = null;

        const RESYNC_INTERVAL = 15 * 60 * 1000;
        const MIN_RESYNC_INTERVAL = 5 * 60 * 1000;
        const INACTIVE_THRESHOLD = 5 * 60 * 1000;
        const TIME_JUMP_THRESHOLD = 2000;

        async function fetchTimeFromNTP() {
            try {
                console.log('≈ÅƒÖczƒô z GUM...');
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000);
                
                const response = await fetch(BACKEND_URL, {
                    signal: controller.signal,
                    cache: 'no-cache'
                });
                
                clearTimeout(timeoutId);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                if (!data.success) throw new Error(data.error || 'Uwaga! Serwer zwr√≥ci≈Ç b≈ÇƒÖd.');
                
                const serverTime = new Date(data.timestamp);
                ntpServerUsed = data.source;
                
                console.log(`‚úì Po≈ÇƒÖczono z NTP GUM: ${data.source}`);
                console.log(`  Czas NTP: ${serverTime.toISOString()}`);
                console.log(`  Typ serwera: ${data.serverType}`);
                console.log(`  Op√≥≈∫nienie: ${(data.delay * 1000).toFixed(2)}ms`);
                console.log(`  Offset NTP: ${(data.offset * 1000).toFixed(2)}ms`);
                
                return { time: serverTime, type: data.serverType };
            } catch (error) {
                console.error('‚úó B≈ÇƒÖd po≈ÇƒÖczenia ze wzorcem czasu:', error.message);
                throw error;
            }
        }

        async function fetchTimeFromFallback(server) {
            try {
                console.log(`≈ÅƒÖczƒô z ${server.name}...`);
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(server.url, {
                    signal: controller.signal,
                    cache: 'no-cache'
                });
                
                clearTimeout(timeoutId);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                const serverTime = server.parse(data);
                console.log(`‚úì Po≈ÇƒÖczono z ${server.name}`);
                return serverTime;
            } catch (error) {
                console.error(`‚úó B≈ÇƒÖd ${server.name}:`, error.message);
                throw error;
            }
        }

        async function initializeTimeSync(isResync = false) {
            const prefix = isResync ? 'üîÑ RESYNC' : 'INIT';
            if (isResync) showSyncingIndicator();
            
            console.log('='.repeat(40));
            console.log(`${prefix} - Synchronizacja czasu z GUM`);
            console.log(`Sync #${++syncCount} | Serwer: ${BACKEND_URL}`);
            console.log('='.repeat(40));
            
            const oldOffset = timeOffset;
            
            try {
                const result = await fetchTimeFromNTP();
                const localTime = new Date();
                timeOffset = result.time.getTime() - localTime.getTime();
                timeSourceUsed = result.type === 'primary' ? 'ntp-primary' : 'ntp-backup';
                lastSyncTime = Date.now();
                
                if (isResync) {
                    const drift = Math.abs(timeOffset - oldOffset);
                    console.log(`üìä Drift wykryty: ${drift}ms`);
                    if (drift > 500) console.warn('‚ö†Ô∏è Du≈ºy drift! Zegar lokalny mocno dryfuje.');
                }
                
                console.log(`üìä Offset: ${timeOffset}ms`);
                console.log(`‚úÖ ≈πr√≥d≈Ço: GUM (${ntpServerUsed})`);
                console.log('='.repeat(40));
                
                updateSyncStatus();
                scheduleNextResync();
                return;
            } catch (error) {
                console.warn('‚ö† GUM niedostƒôpny, ≈ÇƒÖczƒô z serwerem zapasowym...');
            }
            
            for (const server of FALLBACK_SERVERS) {
                try {
                    const serverTime = await fetchTimeFromFallback(server);
                    const localTime = new Date();
                    timeOffset = serverTime.getTime() - localTime.getTime();
                    timeSourceUsed = 'fallback';
                    ntpServerUsed = server.name;
                    lastSyncTime = Date.now();
                    
                    console.log(`üìä Offset czasu: ${timeOffset}ms`);
                    console.log(`‚ö† ≈πr√≥d≈Ço: Fallback (${server.name})`);
                    console.log('='.repeat(40));
                    
                    updateSyncStatus();
                    scheduleNextResync();
                    return;
                } catch (error) {
                    console.warn(`Fallback ${server.name} niedostƒôpny`);
                }
            }
            
            console.log('üî¥ UWAGA: U≈ºywam czasu systemowego');
            console.log('   Brak po≈ÇƒÖczenia z GUM i serwerami zapasowymi');
            console.log('='.repeat(40));
            timeOffset = 0;
            timeSourceUsed = 'system';
            ntpServerUsed = 'Czas systemowy';
            lastSyncTime = Date.now();
            
            updateSyncStatus();
            scheduleNextResync();
        }

        function scheduleNextResync() {
            if (resyncTimer) clearTimeout(resyncTimer);
            resyncTimer = setTimeout(() => {
                console.log('‚è∞ Zaplanowana resynchronizacja');
                initializeTimeSync(true);
            }, RESYNC_INTERVAL);
            
            const nextSync = new Date(Date.now() + RESYNC_INTERVAL);
            console.log(`‚è∞ Nastƒôpny resync: ${nextSync.toLocaleTimeString()}`);
        }

        function showSyncingIndicator() {
            const statusDiv = document.getElementById('sync-status');
            if (statusDiv) {
                statusDiv.classList.remove('hidden');
                statusDiv.classList.add('syncing');
                statusDiv.innerHTML = 'üîÑ <strong>Synchronizujƒô...</strong>';
            }
        }

        function hideStatusIfNeeded() {
            const statusDiv = document.getElementById('sync-status');
            const showStatusCheckbox = document.getElementById('show-status');
            
            if (statusDiv && showStatusCheckbox) {
                statusDiv.classList.remove('syncing');
                
                if (!showStatusCheckbox.checked && 
                    (timeSourceUsed === 'ntp-primary' || timeSourceUsed === 'ntp-backup')) {
                    setTimeout(() => {
                        statusDiv.classList.add('hidden');
                    }, 2000);
                }
            }
        }

        function getSyncedTime() {
            return new Date(Date.now() + timeOffset);
        }

        function updateSyncStatus() {
            let statusDiv = document.getElementById('sync-status');
            if (!statusDiv) {
                statusDiv = document.createElement('div');
                statusDiv.id = 'sync-status';
                document.body.appendChild(statusDiv);
            }
            
            const statusIcons = {
                'ntp-primary': 'üü¢',
                'ntp-backup': 'üü°',
                'fallback': 'üü†',
                'system': 'üî¥'
            };
            
            const statusLabels = {
                'ntp-primary': 'GUM (tempus1)',
                'ntp-backup': 'GUM (tempus2)',
                'fallback': 'Serwer zapasowy',
                'system': 'Czas systemowy'
            };
            
            const icon = statusIcons[timeSourceUsed] || '‚ö™';
            const label = statusLabels[timeSourceUsed] || 'Nieznany';
            const offsetText = timeOffset !== 0 
                ? ` | Offset: ${timeOffset > 0 ? '+' : ''}${timeOffset}ms`
                : '';
            
            statusDiv.innerHTML = `${icon} <strong>${label}</strong><br>
                                   <small>${ntpServerUsed}${offsetText}</small>`;
            
            hideStatusIfNeeded();
        }

        function displaySyncStatus() {
            updateSyncStatus();
        }

        // Safari workaround - resetuj lastTimeCheck przy wznowieniu
        let visibilityResyncTimer = null;
        
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                // Safari fix: resetuj timer skoku czasu
                lastTimeCheck = Date.now();
                
                const timeSinceLastSync = Date.now() - lastSyncTime;
                if (timeSinceLastSync > INACTIVE_THRESHOLD) {
                    console.log('üîÑ Resync: Powr√≥t do karty po nieaktywno≈õci');
                    
                    // Poczekaj 500ms aby Safari obudzi≈Ç sieƒá
                    if (visibilityResyncTimer) clearTimeout(visibilityResyncTimer);
                    visibilityResyncTimer = setTimeout(() => {
                        initializeTimeSync(true);
                    }, 500);
                }
            }
        });

        window.addEventListener('focus', () => {
            // Safari fix: resetuj timer skoku czasu
            lastTimeCheck = Date.now();
            
            const timeSinceLastSync = Date.now() - lastSyncTime;
            if (timeSinceLastSync > INACTIVE_THRESHOLD) {
                console.log('üîÑ Resync: Focus po nieaktywno≈õci');
                
                // Poczekaj 500ms aby Safari obudzi≈Ç sieƒá
                setTimeout(() => {
                    initializeTimeSync(true);
                }, 500);
            }
        });

        let lastTimeCheck = Date.now();
        let timeJumpDetectionEnabled = true;
        
        setInterval(() => {
            // Wy≈ÇƒÖcz detekcjƒô skoku czasu je≈õli karta niewidoczna
            if (document.hidden) {
                timeJumpDetectionEnabled = false;
                return;
            }
            
            // W≈ÇƒÖcz ponownie gdy karta widoczna
            if (!timeJumpDetectionEnabled) {
                timeJumpDetectionEnabled = true;
                lastTimeCheck = Date.now();
                return;
            }
            
            const now = Date.now();
            const expectedDiff = 1000;
            const actualDiff = now - lastTimeCheck;
            
            if (Math.abs(actualDiff - expectedDiff) > TIME_JUMP_THRESHOLD) {
                console.warn(`‚ö†Ô∏è Wykryto skok czasu! (${actualDiff}ms zamiast ${expectedDiff}ms)`);
                
                // Poczekaj chwilƒô przed resync
                setTimeout(() => {
                    console.log('üîÑ Resync: Po skoku czasu');
                    initializeTimeSync(true);
                }, 1000); // Zwiƒôkszone op√≥≈∫nienie dla Safari
            }
            
            lastTimeCheck = now;
        }, 1000);

        const clockEl = document.querySelector('.clock');
        const secondHand = clockEl.querySelector('.second-hand-inner');
        const minuteHand = clockEl.querySelector('.minute-hand-inner');
        const hourHand = clockEl.querySelector('.hour-hand-inner');
        const digitalClock = document.getElementById('digital-clock');
        const analogClock = document.getElementById('analog-clock-container');
        const container = document.getElementById('clocks-container');

        const TRANSFORM_NAME = typeof document.body.style.transform == 'undefined' ? 'webkitTransform' : 'transform';

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        let lastPipSecond = -1;

        const urlParams = new URLSearchParams(window.location.search);
        const antenaEnabled = urlParams.get('antena') === '1';
        const testEnabled = urlParams.get('gum-test') === '1';

        function easeOutQuad(t) { return t * (2 - t) }

        let lastUpdateTime = 0;

        function updateAnalogClock(now) {
            const seconds = now.getSeconds();
            const milliSeconds = now.getMilliseconds() / 1000;
            
            const movementDuration = 0.15;
            const animationProgress = Math.min(milliSeconds / movementDuration, 1);
            const smoothMovement = easeOutQuad(animationProgress);
            let rotation = ((360 / 60) * seconds + smoothMovement * 6 - 6 + 360) % 360;
            secondHand.style[TRANSFORM_NAME] = `rotate(${rotation}deg)`;

            if (seconds !== Math.floor(lastUpdateTime / 1000)) {
                const minutes = now.getMinutes() + seconds / 60;
                rotation = (360 / 60) * minutes;
                minuteHand.style[TRANSFORM_NAME] = `rotate(${rotation}deg)`;

                const hours = now.getHours() % 12 + minutes / 60;
                rotation = (360 / 12) * hours;
                hourHand.style[TRANSFORM_NAME] = `rotate(${rotation}deg)`;
            }

            lastUpdateTime = now.getTime();
        }

        function updateDigitalClock(now) {
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            
            digitalClock.textContent = `${hours}:${minutes}:${seconds}`;
        }

        function updateClocks() {
            const now = getSyncedTime();
            updateAnalogClock(now);
            updateDigitalClock(now);
            requestAnimationFrame(updateClocks);
        }

        function updateLayout() {
            const showAnalog = document.getElementById('show-analog').checked;
            const showDigital = document.getElementById('show-digital').checked;

            analogClock.style.display = showAnalog ? 'block' : 'none';
            digitalClock.style.display = showDigital ? 'block' : 'none';

            let analogSize = showAnalog && !showDigital ? '90vmin' : '80vmin';
            analogClock.style.width = analogSize;
            analogClock.style.height = analogSize;

            let digitalFontSize = parseFloat(analogSize) / 5;
            digitalClock.style.fontSize = `${digitalFontSize}vmin`;
        }

        document.getElementById('show-analog').addEventListener('change', updateLayout);
        document.getElementById('show-digital').addEventListener('change', updateLayout);

        document.getElementById('show-status').addEventListener('change', () => {
            const statusDiv = document.getElementById('sync-status');
            const showStatusCheckbox = document.getElementById('show-status');
            
            if (statusDiv && showStatusCheckbox) {
                if (showStatusCheckbox.checked) {
                    statusDiv.classList.remove('hidden');
                } else {
                    if (timeSourceUsed === 'ntp-primary' || timeSourceUsed === 'ntp-backup') {
                        statusDiv.classList.add('hidden');
                    }
                }
            }
        });

        window.addEventListener('resize', updateLayout);

        window.onload = async function() {
            await initializeTimeSync(false);
            displaySyncStatus();
            updateClocks();
            updateLayout();
        };

        document.body.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }, { once: true });

        const pipsCheckbox = document.getElementById('enable-pips');
        const PIP_FREQUENCY = 950;

        function playPip(duration = 0.1, timeOffset = 0) {
            if (!pipsCheckbox.checked) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(PIP_FREQUENCY, audioCtx.currentTime + timeOffset);
            gainNode.gain.setValueAtTime(1, audioCtx.currentTime + timeOffset);

            oscillator.connect(gainNode).connect(audioCtx.destination);
            oscillator.start(audioCtx.currentTime + timeOffset);
            oscillator.stop(audioCtx.currentTime + timeOffset + duration);
        }

        function checkForPips() {
            if (!pipsCheckbox.checked) return;

            let now = getSyncedTime();

            if (antenaEnabled) {
                now = new Date(now.getTime() + 700);
            }

            const seconds = now.getSeconds();
            const minutes = now.getMinutes();
            const millis = now.getMilliseconds();

            if (seconds === lastPipSecond) return;

            if (minutes == 59 && seconds >= 55 && seconds <= 59 && millis < 150) {
                playPip(0.1);
                lastPipSecond = seconds;
            } else if (minutes == 0 && seconds === 0 && millis < 150) {
                playPip(0.3);
                lastPipSecond = seconds;
            } else if (minutes == 29 && seconds >= 55 && seconds <= 59 && millis < 150) {
                playPip(0.1);
                lastPipSecond = seconds;
            } else if (minutes == 30 && seconds === 0 && millis < 150) {
                playPip(0.3);
                lastPipSecond = seconds;
            }
            
            if (testEnabled) {
                if (minutes == 29 && seconds >= 15 && seconds <= 45 && millis < 150) {
                playPip(0.1);
                lastPipSecond = seconds;
                } else if (minutes == 59 && seconds >= 15 && seconds <= 45 && millis < 150) {
                playPip(0.1);
                lastPipSecond = seconds;
                }
            }
        }

        setInterval(checkForPips, 100);
    </script>
</body>
</html>