<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polskie Radio - Zegar</title>
    <style>
        @font-face {
            font-family: 'DigiClock';
            src: url('fonts/DigiClock.woff') format('woff'),
                 url('fonts/DigiClock.woff2') format('woff2'),
                 url('fonts/DigiClock.svg#DigiClock') format('svg'),
                 url('fonts/DigiClock.eot'),
                 url('fonts/DigiClock.eot?#iefix') format('embedded-opentype'),
                 url('fonts/DigiClock.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-image: url(clock/background.jpg);
            background-size: cover;
            background-attachment: fixed;
            overflow: hidden;
        }

        #clocks-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            padding-top: 3vh;
            padding-bottom: 5vh;
            transform: scale(0.95);
        }

        #analog-clock-container {
            position: relative;
            width: 80vmin;
            height: 80vmin;
            max-width: 90vw;
            max-height: 90vh;
            transition: all 0.3s ease;
        }

        .clock {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-image: url(clock/face.png);
            background-size: contain;
            background-position: 50% 50%;
            background-repeat: no-repeat;
        }

        .clock > * {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
        }
        .clock > * > * {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-size: contain;
            background-position: 50% 50%;
            background-repeat: no-repeat;
            transform-origin: 50% 50%;
        }

        .clock .second-hand { z-index: 100; }
        .clock .second-hand-inner { background-image: url(clock/hand-second.png); }
        .clock .minute-hand { z-index: 99; }
        .clock .minute-hand-inner { background-image: url(clock/hand-minute.png); }
        .clock .hour-hand { z-index: 98; }
        .clock .hour-hand-inner { background-image: url(clock/hand-hour.png); }

        #digital-clock {
            font-family: 'DigiClock';
            color: #f00;
            text-shadow: 0 0 10px #f00;
            margin-top: 20px;
            padding: 20px;
            border: 10px solid #444;
            border-radius: 15px;
            background-color: #000;
            text-align: center;
            transition: all 0.3s ease;
            letter-spacing: -0.40em;
            position: relative;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }

        #controls label {
            font-family: Arial, Helvetica, sans-serif;
            font-size: 14px;
        }

        #sync-status {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 1000;
        }

    </style>
</head>
<body>
    <div id="clocks-container">
        <div id="analog-clock-container">
            <div class='clock' id="analog-clock">
                <div class='hour-hand'><div class='hour-hand-inner'></div></div>
                <div class='minute-hand'><div class='minute-hand-inner'></div></div>
                <div class='second-hand'><div class='second-hand-inner'></div></div>
            </div>
        </div>
        <div id="digital-clock"></div>
    </div>

    <div id="controls">
        <label><input type="checkbox" id="show-analog" checked> Analogowy</label><br>
        <label><input type="checkbox" id="show-digital" checked> Cyfrowy</label><br>
        <label><input type="checkbox" id="enable-pips"> GUM</label>
    </div>

    <script>
        // =============================================================================
        // MODUŁ SYNCHRONIZACJI CZASU Z NTP GUM
        // =============================================================================

        // KONFIGURACJA: Zmień na swój backend lub użyj HTTPS jeśli włączysz Cloudflare Proxy
        const BACKEND_URL = 'https://timeserv.maksplus.xyz/api/time';
        
        // Fallback na publiczne API (gdyby backend nie działał)
        const FALLBACK_SERVERS = [
            {
                name: 'WorldTimeAPI',
                url: 'https://worldtimeapi.org/api/timezone/Europe/Warsaw',
                parse: (data) => new Date(data.datetime)
            }
        ];

        // Zmienne globalne do zarządzania czasem
        let timeOffset = 0;
        let timeSourceUsed = 'system';
        let ntpServerUsed = 'Nieznany';

        /**
         * Pobiera czas z backendu NTP GUM
         */
        async function fetchTimeFromNTP() {
            try {
                console.log('Łączę z GUM...');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 8000);
                
                const response = await fetch(BACKEND_URL, {
                    signal: controller.signal,
                    cache: 'no-cache'
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Uwaga! Serwer zwrócił błąd.');
                }
                
                const serverTime = new Date(data.timestamp);
                ntpServerUsed = data.source;
                
                console.log(`✓ Połączono z NTP GUM: ${data.source}`);
                console.log(`  Czas NTP: ${serverTime.toISOString()}`);
                console.log(`  Typ serwera: ${data.serverType}`);
                console.log(`  Opóźnienie: ${(data.delay * 1000).toFixed(2)}ms`);
                console.log(`  Offset NTP: ${(data.offset * 1000).toFixed(2)}ms`);
                
                return { time: serverTime, type: data.serverType };
                
            } catch (error) {
                console.error('✗ Błąd połączenia ze wzorcem czasu:', error.message);
                throw error;
            }
        }

        /**
         * Pobiera czas z serwera fallback
         */
        async function fetchTimeFromFallback(server) {
            try {
                console.log(`Łączę z ${server.name}...`);
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(server.url, {
                    signal: controller.signal,
                    cache: 'no-cache'
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                const serverTime = server.parse(data);
                
                console.log(`✓ Połączono z ${server.name}`);
                
                return serverTime;
                
            } catch (error) {
                console.error(`✗ Błąd ${server.name}:`, error.message);
                throw error;
            }
        }

        /**
         * Inicjalizuje synchronizację czasu
         */
        async function initializeTimeSync() {
            console.log('='.repeat(40));
            console.log('INICJALIZACJA SYNCHRONIZACJI CZASU Z GUM');
            console.log('Serwer obsługi wzorca czasu: ' + BACKEND_URL);
            console.log('='.repeat(40));
            
            // Próba 1: Backend NTP GUM (tempus1 lub tempus2)
            try {
                const result = await fetchTimeFromNTP();
                const localTime = new Date();
                timeOffset = result.time.getTime() - localTime.getTime();
                timeSourceUsed = result.type === 'primary' ? 'ntp-primary' : 'ntp-backup';
                
                console.log(`📊 Offset: ${timeOffset}ms`);
                console.log(`✅ Źródło: GUM (${ntpServerUsed})`);
                console.log('='.repeat(40));
                return;
            } catch (error) {
                console.warn('⚠ GUM niedostępny, łączę z serwerem zapasowym...');
            }
            
            // Próba 2: Fallback na publiczne API
            for (const server of FALLBACK_SERVERS) {
                try {
                    const serverTime = await fetchTimeFromFallback(server);
                    const localTime = new Date();
                    timeOffset = serverTime.getTime() - localTime.getTime();
                    timeSourceUsed = 'fallback';
                    ntpServerUsed = server.name;
                    
                    console.log(`📊 Offset czasu: ${timeOffset}ms`);
                    console.log(`⚠ Źródło: Fallback (${server.name})`);
                    console.log('='.repeat(40));
                    return;
                } catch (error) {
                    console.warn(`Fallback ${server.name} niedostępny`);
                }
            }
            
            // Próba 3: Czas systemowy
            console.log('🔴 UWAGA: Używam czasu systemowego');
            console.log('   Brak połączenia z GUM i serwerami zapasowymi');
            console.log('='.repeat(40));
            timeOffset = 0;
            timeSourceUsed = 'system';
            ntpServerUsed = 'Czas systemowy';
        }

        /**
         * Zwraca zsynchronizowany czas
         */
        function getSyncedTime() {
            return new Date(Date.now() + timeOffset);
        }

        /**
         * Wyświetla status synchronizacji
         */
        function displaySyncStatus() {
            const statusDiv = document.createElement('div');
            statusDiv.id = 'sync-status';
            
            const statusIcons = {
                'ntp-primary': '🟢',
                'ntp-backup': '🟡',
                'fallback': '🟠',
                'system': '🔴'
            };
            
            const statusLabels = {
                'ntp-primary': 'GUM (tempus1)',
                'ntp-backup': 'GUM (tempus2)',
                'fallback': 'Serwer zapasowy',
                'system': 'Czas systemowy'
            };
            
            const icon = statusIcons[timeSourceUsed] || '⚪';
            const label = statusLabels[timeSourceUsed] || 'Nieznany';
            const offsetText = timeOffset !== 0 
                ? ` | Offset: ${timeOffset > 0 ? '+' : ''}${timeOffset}ms`
                : '';
            
            statusDiv.innerHTML = `${icon} <strong>${label}</strong><br>
                                   <small>${ntpServerUsed}${offsetText}</small>`;
            document.body.appendChild(statusDiv);
        }

        // =============================================================================
        // KONIEC MODUŁU SYNCHRONIZACJI
        // =============================================================================

        // Cachowanie referencji do elementów DOM
        const clockEl = document.querySelector('.clock');
        const secondHand = clockEl.querySelector('.second-hand-inner');
        const minuteHand = clockEl.querySelector('.minute-hand-inner');
        const hourHand = clockEl.querySelector('.hour-hand-inner');
        const digitalClock = document.getElementById('digital-clock');
        const analogClock = document.getElementById('analog-clock-container');
        const container = document.getElementById('clocks-container');

        const TRANSFORM_NAME = typeof document.body.style.transform == 'undefined' ? 'webkitTransform' : 'transform';

        // Inicjalizacja AudioContext do generowania dźwięku
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        let lastPipSecond = -1;

        // Sprawdzenie, czy aktywna jest opcja "antena"
        const urlParams = new URLSearchParams(window.location.search);
        const antenaEnabled = urlParams.get('antena') === '1';
        const testEnabled = urlParams.get('gum-test') === '1';

        // Funkcja do płynnej animacji
        function easeOutQuad(t) { return t * (2 - t) }

        let lastUpdateTime = 0;

        function updateAnalogClock(now) {
            const seconds = now.getSeconds();
            const milliSeconds = now.getMilliseconds() / 1000;
            
            // Aktualizacja sekundnika
            const movementDuration = 0.15;
            const animationProgress = Math.min(milliSeconds / movementDuration, 1);
            const smoothMovement = easeOutQuad(animationProgress);
            let rotation = ((360 / 60) * seconds + smoothMovement * 6 - 6 + 360) % 360;
            secondHand.style[TRANSFORM_NAME] = `rotate(${rotation}deg)`;

            // Aktualizacja minutnika i godzinnika co sekundę
            if (seconds !== Math.floor(lastUpdateTime / 1000)) {
                const minutes = now.getMinutes() + seconds / 60;
                rotation = (360 / 60) * minutes;
                minuteHand.style[TRANSFORM_NAME] = `rotate(${rotation}deg)`;

                const hours = now.getHours() % 12 + minutes / 60;
                rotation = (360 / 12) * hours;
                hourHand.style[TRANSFORM_NAME] = `rotate(${rotation}deg)`;
            }

            lastUpdateTime = now.getTime();
        }

        function updateDigitalClock(now) {
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            
            digitalClock.textContent = `${hours}:${minutes}:${seconds}`;
        }

        function updateClocks() {
            const now = getSyncedTime();
            updateAnalogClock(now);
            updateDigitalClock(now);
            requestAnimationFrame(updateClocks);
        }

        function updateLayout() {
            const showAnalog = document.getElementById('show-analog').checked;
            const showDigital = document.getElementById('show-digital').checked;

            analogClock.style.display = showAnalog ? 'block' : 'none';
            digitalClock.style.display = showDigital ? 'block' : 'none';

            let analogSize = showAnalog && !showDigital ? '90vmin' : '80vmin';
            analogClock.style.width = analogSize;
            analogClock.style.height = analogSize;

            let digitalFontSize = parseFloat(analogSize) / 5;
            digitalClock.style.fontSize = `${digitalFontSize}vmin`;
        }

        document.getElementById('show-analog').addEventListener('change', updateLayout);
        document.getElementById('show-digital').addEventListener('change', updateLayout);

        window.addEventListener('resize', updateLayout);

        // Inicjalizacja zegarów po załadowaniu strony
        window.onload = async function() {
            await initializeTimeSync();
            displaySyncStatus();
            updateClocks();
            updateLayout();
        };

        // Odblokowanie AudioContext po pierwszym kliknięciu
        document.body.addEventListener('click', () => {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }, { once: true });

        // Użytkownik może włączyć/wyłączyć piki
        const pipsCheckbox = document.getElementById('enable-pips');

        // Domyślna częstotliwość pipów (możesz zmienić)
        const PIP_FREQUENCY = 950;

        // Funkcja generująca pojedynczy pip
        function playPip(duration = 0.1, timeOffset = 0) {
            if (!pipsCheckbox.checked) return;

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(PIP_FREQUENCY, audioCtx.currentTime + timeOffset);
            gainNode.gain.setValueAtTime(1, audioCtx.currentTime + timeOffset);

            oscillator.connect(gainNode).connect(audioCtx.destination);
            oscillator.start(audioCtx.currentTime + timeOffset);
            oscillator.stop(audioCtx.currentTime + timeOffset + duration);
        }

        // Funkcja sprawdzająca i odtwarzająca pipy od xx:59:55 do xx:00:00
        function checkForPips() {
            if (!pipsCheckbox.checked) return;

            let now = getSyncedTime();

            if (antenaEnabled) {
                now = new Date(now.getTime() + 700);  // dźwięk nastąpi wcześniej
            }

            const seconds = now.getSeconds();
            const minutes = now.getMinutes();
            const millis = now.getMilliseconds();

            // Jeśli już był pip w tej sekundzie – pomiń
            if (seconds === lastPipSecond) return;

            if (minutes == 59 && seconds >= 55 && seconds <= 59 && millis < 150) {
                playPip(0.1);
                lastPipSecond = seconds;
            } else if (minutes == 0 && seconds === 0 && millis < 150) {
                playPip(0.3);
                lastPipSecond = seconds;
            } else if (minutes == 29 && seconds >= 55 && seconds <= 59 && millis < 150) {
                playPip(0.1);
                lastPipSecond = seconds;
            } else if (minutes == 30 && seconds === 0 && millis < 150) {
                playPip(0.3);
                lastPipSecond = seconds;
            }
            
            if (testEnabled) {
                if (minutes == 29 && seconds >= 15 && seconds <= 45 && millis < 150) {
                playPip(0.1);
                lastPipSecond = seconds;
                } else if (minutes == 59 && seconds >= 15 && seconds <= 45 && millis < 150) {
                playPip(0.1);
                lastPipSecond = seconds;
                }
            }
        }

        // Sprawdzanie co 100 ms
        setInterval(checkForPips, 100);
    </script>
</body>
</html>